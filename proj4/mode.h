#ifndef MODE_H
#define MODE_H

#include"mapinfor.h"
#include<algorithm>
#include<numeric>
#include<climits>
#include<map>
#include<queue>

using namespace std;

struct subset
{
	int lowerBound;
	int circleLength; // This is not the true current circleLength, but back track one point
	unsigned long long nthPerm;
};

struct subsetComp
{
	bool operator()(const subset& sb1, const subset& sb2)
	{
		if(sb1.lowerBound>sb2.lowerBound)
			return true;
		else
			return false;
	}
};

// compute the MST, return the vector Dv only
// return the path of the MST as a vector, for each element in the vector, the index is its ancester
vector<int> computeMST(const adjMat& adjMat1);

// print out the weight and the path of the MST
void printMST(const adjMat& adjMat1, const vector<int>& path);

// for part c, compute the path generated by existing MST
// return the path
vector<int> pathFromMST(const vector<int>& path);

// using the 2-opt technique based on the circle from MST
void optFromMST(const adjMat& adjMat1, vector<int>& pathFromMST, int& cursorPos, int& totalDist);

// helper function for the function optFromMST. 
// This function test whether the two edges can be adjusted so that the total dist of the circle path is less, if yes, return true and do the adjustment
bool exchangeVertex(const adjMat& adjMat1, vector<int>& currentPath, int baseNum, int cursorPos, int dist, int& totalDist);

// helper function to help compute distance based on the circle route
int totalDistance(const adjMat& adjMat1, const vector<int>& currentPath);

// print out the FASTTSP
void printFASTTSP(const adjMat& adjMat1, const vector<int>& pathFASTTSP);

// retuen the weight in sorted order for each base
vector<vector<int> > sortedDistanceMatrix(const adjMat& adjMat1);

// function that returns a vector of the needed factorail computation for the lookup
vector<unsigned long long> factorialVec(int baseNum);

// function to compute the nth result of the permutation, in the parameters, orderBook is a all the numbers in
// the sequential order, permutation if the result of the generated permutation result;
vector<int> nthFactorial(const vector<unsigned long long>& factorialRecord, int baseNum, unsigned long long nth);

void nthFactorial(unsigned long long& reminder, const vector<unsigned long long>& factorialRecord, vector<int>& orderBook, vector<int>& permutation);

// compute the lowerBound by computing the backPath
int computeBackpath(const vector<int>& path, const vector<vector<int> >& weightMat, int circleLength, int i, int baseNum);

// compute the lowerBound by the currentDistance and the two nearest points of each point
int computeLowerBound(const vector<vector<int> >& SDM, const vector<vector<int> >& weightMat, int baseNum, const vector<int>& data, int i, int& circleLength);

int computeLowerBoundPQ(const vector<vector<int> >& SDM, const vector<vector<int> >& weightMat, int baseNum, const vector<int>& data, int i); // used for lowerBound computation in priority queue

// find the circle path of the OPTTSP, and change the value of upperBound, after the change it is the lowest possible totalWeight
vector<int> findOPTTSP(const adjMat& adjMat1, int& upperBound, vector<int>& OPTTSPPath);
void findOPTTSP(const vector<unsigned long long> factorialRecord, const vector<vector<int> >& SDM, const vector<vector<int> > weightMat, int baseNum, int& upperBound, vector<int>& OPTTSPPath, vector<int>& data, unsigned long long permNum, int divideNum);

// cheaper way to copy part of a vector
vector<int> copyVector(const vector<int>& data, vector<int>& data1, int checkPoint, int baseNum);

// computer the factorial
unsigned long long factorial(int n);

// print out the OPTTSP
void printOPTTSP(int upperBound, const vector<int>& OPTTSPPath);

#endif
